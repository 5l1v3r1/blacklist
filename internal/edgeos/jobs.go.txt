package edgeos

// Jobber implements JobLoader
type Jobber interface {
}

// Job holds job information
type Job struct {
	results chan<- Result
	src     []string
}

// Result holds returned data
type Result struct {
	// Data  []byte
	// Error error
	// Src   *config.Src
}

// RunJobs assembles the http download jobs
func RunJobs(src []string, cores int) {
	jobs := make(chan Job, cores)
	results := make(chan Result, len(src))
	done := make(chan struct{}, cores)

	go addJobs(jobs, src, results)
	for i := 0; i < cores; i++ {
		go doJobs(done, jobs)
	}
	// TODO: getResults(timeout, done, results)
	return
}

// getResults collects the HTTP content and sends it to processResults
// func (c *Cfg) getResults(timeout time.Duration, dex config.Dict, ex config.Dict, done <-chan struct{},
// 	results <-chan Result) {
//
// 	log := c.Log
// 	finish := time.After(time.Duration(timeout))
//
// 	for working := cores; working > 0; {
// 		select {
// 		case result := <-results:
// 			if err := c.processResults(&result, dex, ex); err != nil {
// 				log.Errorf("processResults(): %v\n", err)
// 			}
//
// 		case <-finish:
// 			log.Error("getResults() timed out\n")
//
// 		case <-done:
// 			working--
// 		}
// 	}
// 	for {
// 		select {
// 		case result := <-results:
// 			if err := c.processResults(&result, dex, ex); err != nil {
// 				log.Errorf("processResults(): %v\n", err)
// 			}
//
// 		case <-finish:
// 			log.Errorf("getResults() timed out\n")
//
// 		default:
// 			return
// 		}
// 	}
// }

// do is the pre-configured and http content loader
func (job Job) do() {
	// var (
	// 	body []byte
	// )
	// var err error
	// switch {
	// case job.src.Name == g.PreName:
	// 	for key := range job.src.List {
	// 		body = append(body, fmt.Sprintf("%v\n", key)...)
	// 	}
	//
	// default:
	// body, err = c.GetHTTP(job.src.URL)
	// if err != nil {
	// 	g.Log.Errorf("Problem retrieving data from %v: %s", job.src.URL, err)
	// }
	// }

	// job.results <- Result{Src: job.src, Data: body, Error: err}
}

// addJobs puts jobs on the tasklist
func addJobs(jobs chan<- Job, urls []string, results chan<- Result) {
	for _, url := range urls {
		// url.No = i + 1
		jobs <- Job{src: url, results: results}
		// g.Log.Printf("Adding download: (%v) %v\n", url.Type, url.Name)
	}
	close(jobs)
}

// doJobs supervises the jobs and uses an empty struct to signal completion
func (job Job) doJobs(done chan<- struct{}, jobs <-chan Job) {
	for job := range jobs {
		job.do()
		// g.Log.Printf("Running job[%v]: (%v) %v\n", job.src.No, job.src.Type, job.src.Name)
	}
	done <- struct{}{}
}
